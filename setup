#!/bin/bash
#
# Small script that fills in common env vars for all configs and 
# scripts (excluding dotfiles). These common env vars 
# are denoted by SUBST_VARS.

#######################################
# Usage string for the program.
# Globals:
#   PROGRAM_NAME
# Outputs:
#   - usage heredoc string to stdout
# Returns:
#   0 - cat success
#   1 - cat error
#######################################
usage () {
	cat << _EOF_
Usage: $PROGRAM_NAME [-h] [-u]

Each 'original' script/cfg file gets shifted name wise temporarily.
With the new replacement file being a copy but having its env vars
evaluated based on the env vars read from '$ENV_FILENAME' (also the
copy's filename is that of the original's filename).

Options:
    -h	display usage str and exit
    -u	undo script/cfg file changes

_EOF_
	return
}

set -e
PROGRAM_NAME=$(basename "$0")
ENV_FILENAME=".env"
# ORIG = ORIGINAL
ORIG_PREFIX="_"
# shellcheck disable=2016
SUBST_VARS=(
    '${JENKINS_MAIN_URL}'
)

# NOTE: opt is unset incase it has been defined previously;
# getops will place the next option (e.g. o, t) into name;
unset opt
while getopts "hu" opt; do
	case "$opt" in
	# -u is for 'undo'
	"u")    UNDO="true"
			;;
	"h")	usage
			exit 0
			;;
	":")    echo "${PROGRAM_NAME}: an argument is required for -- $OPTARG"
			exit 1
			;;
    *)		# NOTE: using the program with no arguments will cause '?'
			# to be inserted into $opt. However, I've found getopts seems to
			# handle unknown options (at least those not found in the opt str).
			# 'shellcheck' seems to say otherwise, and that a default case is needed.
			usage
			exit 1
			;;
    esac
done

if [ -z "$(find "$PWD" -maxdepth 1 -name "$ENV_FILENAME")" ]; then
	echo "${PROGRAM_NAME}: ${ENV_FILENAME} is not in the PWD!"
	exit 1
fi

if [ -z "$(which envsubst)" ]; then
	echo "${PROGRAM_NAME}: envsubst cannot be found on the PATH!"
	exit 1
fi

if [ -z "$(which dirname)" ]; then
	echo "${PROGRAM_NAME}: dirname cannot be found on the PATH!"
	exit 1
fi

if [ -z "$(which pathjoin)" ]; then
	echo "${PROGRAM_NAME}: pathjoin cannot be found on the PATH!"
	exit 1
fi

walkdirtree () {
    DIR="$1"
    # shellcheck disable=2181,2063
    # NOTE: I've seen bizarre occurances where
    # filenames have a '*' character appended to them
    # 
    # is the directory not empty?
    if [ "$(find "$DIR" | wc --lines)" -gt 1 ]; then
        for f in "$DIR"/*; do
            if [ -d "$f" ]; then
                walkdirtree "$f"
            elif grep --quiet \* <<< "$f"; then
                continue
            else 
                echo "$f"
            fi
        done
    fi
}

# shellcheck disable=1090
. "$ENV_FILENAME"

# NOTE: the intention is to concatenate the str
# to the array. This sort of thing is 'rarely intended' 
# according to shellcheck.
# shellcheck disable=2145
# fp file_path
for fp in $(walkdirtree "$PWD"); do
    # \..* for ignoring dotfiles
    case "$fp" in
        "${PWD}/${PROGRAM_NAME}")	;;
		\..*)						;;
        *)							ORIG_FILE_PATH=$(pathjoin "$(dirname "${fp}")" "${ORIG_PREFIX}$(basename "${fp}")");
                                    # NOTE: its possible the original file was never moved over or 
                                    # that it could have been deleted. Useful incase we wish to run PROGRAM_NAME
                                    # again.
                                    if ! [ -f "$ORIG_FILE_PATH" ]; then mv "$fp" "$ORIG_FILE_PATH"; fi
                                    if [ -n "$UNDO" ] && [ -f "$ORIG_FILE_PATH" ]; then mv "$ORIG_FILE_PATH" "$fp"; continue; fi
                                    envsubst "'${SUBST_VARS[@]}'" < "$ORIG_FILE_PATH" > "$fp"
                                    # assign same filemode permissions from the original file to the new copy
                                    chmod "$(stat --format "%a" "$ORIG_FILE_PATH")" "$fp"
									;;
    esac
done

exit 0
